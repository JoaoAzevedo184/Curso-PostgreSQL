# Campos Default no PostgreSQL

## Introdução

Os campos default (valores padrão) no PostgreSQL permitem definir valores automáticos para colunas quando nenhum valor é especificado durante a inserção de dados. Isso garante consistência, simplifica operações de inserção e pode implementar lógicas de negócio automaticamente.

## Sintaxe Básica

```sql
CREATE TABLE nome_tabela (
    coluna tipo_dado DEFAULT valor_default,
    -- outras colunas
);
```

## Tipos de Valores Default

### 1. Valores Literais

Valores fixos como números, strings ou booleanos:

```sql
CREATE TABLE usuarios (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    status VARCHAR(20) DEFAULT 'ativo',
    idade INTEGER DEFAULT 18,
    premium BOOLEAN DEFAULT false,
    criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 2. Funções do Sistema

PostgreSQL oferece várias funções úteis para valores default:

```sql
CREATE TABLE logs (
    id SERIAL PRIMARY KEY,
    evento TEXT NOT NULL,
    data_evento TIMESTAMP DEFAULT NOW(),
    data_atual DATE DEFAULT CURRENT_DATE,
    hora_atual TIME DEFAULT CURRENT_TIME,
    usuario_sistema TEXT DEFAULT USER,
    uuid_registro UUID DEFAULT gen_random_uuid()
);
```

### 3. Expressões e Cálculos

É possível usar expressões matemáticas ou concatenações:

```sql
CREATE TABLE produtos (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    codigo VARCHAR(20) DEFAULT 'PROD-' || nextval('seq_produto'),
    preco DECIMAL(10,2) DEFAULT 0.00,
    desconto DECIMAL(5,2) DEFAULT 0.05,
    preco_final DECIMAL(10,2) DEFAULT (preco * (1 - desconto))
);
```

## Funções Comuns para Default

### Funções de Data e Hora

```sql
-- Data e hora atual
DEFAULT NOW()
DEFAULT CURRENT_TIMESTAMP

-- Apenas data atual
DEFAULT CURRENT_DATE

-- Apenas hora atual
DEFAULT CURRENT_TIME

-- Data específica
DEFAULT '2024-01-01'::DATE

-- Intervalos
DEFAULT (CURRENT_DATE + INTERVAL '30 days')
```

### Funções de String

```sql
-- Concatenação
DEFAULT 'PREFIX_' || generate_random_uuid()

-- Funções de string
DEFAULT UPPER('valor')
DEFAULT LOWER('VALOR')
DEFAULT 'Texto ' || CURRENT_USER
```

### Funções Numéricas

```sql
-- Valores aleatórios
DEFAULT RANDOM()
DEFAULT (RANDOM() * 100)::INTEGER

-- Sequências
DEFAULT nextval('minha_sequencia')
```

## Trabalhando com Sequences

### Criando Sequence para Default

```sql
-- Criar sequence
CREATE SEQUENCE seq_codigo_produto START 1000;

-- Usar na tabela
CREATE TABLE produtos (
    id SERIAL PRIMARY KEY,
    codigo INTEGER DEFAULT nextval('seq_codigo_produto'),
    nome VARCHAR(100) NOT NULL
);
```

### SERIAL vs IDENTITY (PostgreSQL 10+)

```sql
-- Método tradicional (SERIAL)
CREATE TABLE tabela1 (
    id SERIAL PRIMARY KEY
);

-- Método moderno (IDENTITY)
CREATE TABLE tabela2 (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY
);

-- IDENTITY com opções
CREATE TABLE tabela3 (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY 
    (START WITH 100 INCREMENT BY 5) PRIMARY KEY
);
```

## Modificando Valores Default

### Adicionar Default a Coluna Existente

```sql
ALTER TABLE usuarios 
ALTER COLUMN status SET DEFAULT 'pendente';
```

### Remover Default

```sql
ALTER TABLE usuarios 
ALTER COLUMN status DROP DEFAULT;
```

### Alterar Default Existente

```sql
ALTER TABLE usuarios 
ALTER COLUMN idade SET DEFAULT 21;
```

## Valores Default Complexos

### Usando Condicionais

```sql
CREATE TABLE pedidos (
    id SERIAL PRIMARY KEY,
    data_pedido TIMESTAMP DEFAULT NOW(),
    status VARCHAR(20) DEFAULT 
        CASE 
            WHEN EXTRACT(hour FROM NOW()) BETWEEN 9 AND 17 
            THEN 'processando'
            ELSE 'pendente'
        END
);
```

### Valores Default com JSON/JSONB

```sql
CREATE TABLE configuracoes (
    id SERIAL PRIMARY KEY,
    usuario_id INTEGER NOT NULL,
    config JSONB DEFAULT '{"theme": "dark", "notifications": true}'::JSONB,
    metadados JSONB DEFAULT '{}'::JSONB
);
```

### Arrays como Default

```sql
CREATE TABLE permissoes (
    id SERIAL PRIMARY KEY,
    usuario_id INTEGER NOT NULL,
    roles TEXT[] DEFAULT ARRAY['user'],
    tags TEXT[] DEFAULT '{}'::TEXT[]
);
```

## Boas Práticas

### 1. Documentação Clara

```sql
-- Sempre documente o propósito dos defaults
CREATE TABLE auditoria (
    id SERIAL PRIMARY KEY,
    tabela VARCHAR(50) NOT NULL,
    operacao VARCHAR(10) NOT NULL,
    -- Default: registra automaticamente quando o registro foi criado
    criado_em TIMESTAMP DEFAULT NOW(),
    -- Default: identifica o usuário que fez a operação
    usuario VARCHAR(50) DEFAULT USER
);
```

### 2. Validação de Defaults

```sql
CREATE TABLE eventos (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    -- Default com validação
    prioridade INTEGER DEFAULT 5 CHECK (prioridade BETWEEN 1 AND 10),
    -- Default que garante valor válido
    categoria VARCHAR(20) DEFAULT 'geral' 
        CHECK (categoria IN ('geral', 'urgente', 'sistema'))
);
```

### 3. Defaults Condicionais com Triggers

```sql
CREATE OR REPLACE FUNCTION set_codigo_produto()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.codigo IS NULL THEN
        NEW.codigo := 'PROD-' || to_char(NOW(), 'YYYY') || 
                      '-' || nextval('seq_produto');
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_codigo_produto
    BEFORE INSERT ON produtos
    FOR EACH ROW
    EXECUTE FUNCTION set_codigo_produto();
```

## Exemplos Práticos

### Sistema de Usuários

```sql
CREATE TABLE usuarios_sistema (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    senha_hash VARCHAR(255) NOT NULL,
    
    -- Defaults para controle
    ativo BOOLEAN DEFAULT true,
    email_verificado BOOLEAN DEFAULT false,
    tentativas_login INTEGER DEFAULT 0,
    
    -- Defaults temporais
    criado_em TIMESTAMP DEFAULT NOW(),
    ultimo_login TIMESTAMP DEFAULT NULL,
    expira_em TIMESTAMP DEFAULT (NOW() + INTERVAL '1 year'),
    
    -- Defaults com lógica
    codigo_ativacao UUID DEFAULT gen_random_uuid(),
    nivel_acesso INTEGER DEFAULT 1
);
```

### Sistema de Pedidos

```sql
CREATE SEQUENCE seq_numero_pedido START 1000;

CREATE TABLE pedidos (
    id SERIAL PRIMARY KEY,
    numero_pedido VARCHAR(20) DEFAULT 'PED-' || nextval('seq_numero_pedido'),
    cliente_id INTEGER NOT NULL,
    
    -- Status com default inteligente
    status VARCHAR(20) DEFAULT 'novo',
    
    -- Valores financeiros
    subtotal DECIMAL(10,2) DEFAULT 0.00,
    taxa_entrega DECIMAL(10,2) DEFAULT 5.00,
    desconto DECIMAL(10,2) DEFAULT 0.00,
    total DECIMAL(10,2) DEFAULT 0.00,
    
    -- Controle temporal
    criado_em TIMESTAMP DEFAULT NOW(),
    prazo_entrega TIMESTAMP DEFAULT (NOW() + INTERVAL '3 days'),
    
    -- Metadados
    observações TEXT DEFAULT '',
    canal_venda VARCHAR(20) DEFAULT 'online'
);
```

## Considerações Importantes

### Performance
- Defaults simples (valores literais) não impactam performance
- Funções complexas podem ser custosas em inserções em massa
- Consider usar triggers para lógicas muito complexas

### Replicação
- Defaults baseados em tempo podem causar inconsistências em réplicas
- Use funções determinísticas quando possível

### Migração de Dados
- Ao adicionar default a tabelas grandes, considere o impacto
- Teste defaults em ambiente de desenvolvimento primeiro

## Verificando Defaults Existentes

```sql
-- Ver defaults de uma tabela específica
SELECT 
    column_name,
    data_type,
    column_default,
    is_nullable
FROM information_schema.columns 
WHERE table_name = 'nome_da_tabela'
    AND column_default IS NOT NULL;

-- Ver todas as sequences e seus defaults
SELECT 
    schemaname,
    sequencename,
    start_value,
    increment_by,
    max_value,
    min_value
FROM pg_sequences;
```

Os campos default são uma ferramenta poderosa para manter a integridade e consistência dos dados, automatizar processos e simplificar operações de inserção no PostgreSQL.