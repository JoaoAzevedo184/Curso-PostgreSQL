# Campos de Auto Incremento - PostgreSQL

Os campos de auto incremento no PostgreSQL são utilizados para gerar valores únicos automaticamente, sendo fundamentais para chaves primárias e identificadores únicos. O PostgreSQL oferece várias abordagens para implementar este comportamento.

## Conceitos Fundamentais

### O que são Campos de Auto Incremento?
Campos que geram valores numéricos únicos automaticamente a cada nova inserção, eliminando a necessidade de especificar valores manualmente para identificadores.

### Benefícios
- **Unicidade garantida**: Cada registro recebe um identificador único
- **Simplicidade**: Não é necessário gerenciar manualmente os valores
- **Performance**: Otimizado para inserções rápidas
- **Concorrência**: Seguro para múltiplos usuários simultâneos

## Tipos de Auto Incremento no PostgreSQL

### 1. SERIAL (Tradicional)

O tipo `SERIAL` é a forma clássica de criar campos auto incremento no PostgreSQL.

#### Tipos SERIAL Disponíveis
```sql
-- SMALLSERIAL: 2 bytes, valores de 1 a 32.767
-- SERIAL: 4 bytes, valores de 1 a 2.147.483.647
-- BIGSERIAL: 8 bytes, valores de 1 a 9.223.372.036.854.775.807
```

#### Criando Tabela com SERIAL
```sql
-- Exemplo básico com SERIAL
CREATE TABLE usuarios (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE NOT NULL,
    data_cadastro TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Exemplo com BIGSERIAL para grandes volumes
CREATE TABLE transacoes (
    transacao_id BIGSERIAL PRIMARY KEY,
    usuario_id INTEGER NOT NULL,
    valor DECIMAL(10,2) NOT NULL,
    data_transacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    tipo VARCHAR(20) NOT NULL
);
```

#### Inserindo Dados com SERIAL
```sql
-- Inserção sem especificar o ID
INSERT INTO usuarios (nome, email) 
VALUES ('João Silva', 'joao@email.com');

-- Inserção múltipla
INSERT INTO usuarios (nome, email) VALUES 
    ('Maria Santos', 'maria@email.com'),
    ('Pedro Oliveira', 'pedro@email.com'),
    ('Ana Costa', 'ana@email.com');

-- Verificar os IDs gerados
SELECT * FROM usuarios ORDER BY id;
```

### 2. IDENTITY (Recomendado - SQL Padrão)

O tipo `IDENTITY` é a implementação do padrão SQL e é recomendado para novas aplicações.

#### Sintaxe IDENTITY
```sql
-- GENERATED ALWAYS: Sempre gera o valor automaticamente
-- GENERATED BY DEFAULT: Permite especificar valores manualmente

CREATE TABLE produtos (
    produto_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    preco DECIMAL(8,2) NOT NULL,
    categoria_id INTEGER
);

-- Permitindo valores manuais quando necessário
CREATE TABLE categorias (
    categoria_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nome_categoria VARCHAR(50) NOT NULL,
    descricao TEXT
);
```

#### Opções Avançadas do IDENTITY
```sql
-- Configurações personalizadas
CREATE TABLE pedidos (
    pedido_id INTEGER GENERATED ALWAYS AS IDENTITY (
        START WITH 1000      -- Começar do 1000
        INCREMENT BY 1       -- Incrementar de 1 em 1
        MINVALUE 1000       -- Valor mínimo
        MAXVALUE 999999     -- Valor máximo
        CACHE 10            -- Cache de 10 valores
    ) PRIMARY KEY,
    cliente_id INTEGER NOT NULL,
    data_pedido DATE DEFAULT CURRENT_DATE,
    valor_total DECIMAL(10,2)
);
```

### 3. Sequences (Controle Manual)

Sequences oferecem controle total sobre a geração de números sequenciais.

#### Criando e Usando Sequences
```sql
-- Criar uma sequence
CREATE SEQUENCE seq_funcionario_id
    START WITH 1
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 999999
    CACHE 5;

-- Usar sequence em tabela
CREATE TABLE funcionarios (
    funcionario_id INTEGER DEFAULT nextval('seq_funcionario_id') PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    departamento VARCHAR(50),
    salario DECIMAL(8,2),
    data_admissao DATE DEFAULT CURRENT_DATE
);

-- Inserção usando a sequence
INSERT INTO funcionarios (nome, departamento, salario) 
VALUES ('Carlos Silva', 'TI', 5000.00);
```

## Gerenciamento de Sequences

### Consultar Informações de Sequences
```sql
-- Listar todas as sequences
SELECT schemaname, sequencename, last_value, increment_by
FROM pg_sequences
WHERE schemaname = 'public';

-- Valor atual de uma sequence específica
SELECT currval('usuarios_id_seq');

-- Próximo valor sem consumi-lo
SELECT nextval('usuarios_id_seq');

-- Último valor gerado
SELECT lastval();
```

### Modificar Sequences
```sql
-- Alterar valor atual
SELECT setval('usuarios_id_seq', 1000);

-- Alterar configurações
ALTER SEQUENCE usuarios_id_seq 
    INCREMENT BY 2
    MAXVALUE 50000
    CACHE 20;

-- Reiniciar sequence
ALTER SEQUENCE usuarios_id_seq RESTART WITH 1;
```

### Resetar Auto Incremento
```sql
-- Resetar para o próximo valor após o maior ID existente
SELECT setval('usuarios_id_seq', COALESCE((SELECT MAX(id) FROM usuarios), 0) + 1, false);

-- Truncar tabela e resetar sequence
TRUNCATE TABLE usuarios RESTART IDENTITY;
```

## Exemplos Práticos Avançados

### Sistema de Numeração Personalizada
```sql
-- Sequence para número de nota fiscal
CREATE SEQUENCE seq_nota_fiscal
    START WITH 1
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 999999
    CACHE 1;

CREATE TABLE nota_fiscal (
    id SERIAL PRIMARY KEY,
    numero_nf INTEGER DEFAULT nextval('seq_nota_fiscal'),
    cliente_id INTEGER NOT NULL,
    data_emissao DATE DEFAULT CURRENT_DATE,
    valor_total DECIMAL(10,2) NOT NULL,
    -- Garantir que o número da NF seja único
    CONSTRAINT uk_numero_nf UNIQUE (numero_nf)
);
```

### Auto Incremento com Prefixo
```sql
-- Função para gerar código com prefixo
CREATE OR REPLACE FUNCTION gerar_codigo_produto()
RETURNS TEXT AS $$
DECLARE
    proximo_numero INTEGER;
BEGIN
    SELECT nextval('seq_produto_codigo') INTO proximo_numero;
    RETURN 'PROD-' || LPAD(proximo_numero::TEXT, 6, '0');
END;
$$ LANGUAGE plpgsql;

-- Sequence para códigos de produto
CREATE SEQUENCE seq_produto_codigo START 1;

-- Tabela usando a função
CREATE TABLE produtos_codigo (
    id SERIAL PRIMARY KEY,
    codigo VARCHAR(11) DEFAULT gerar_codigo_produto() UNIQUE,
    nome VARCHAR(100) NOT NULL,
    preco DECIMAL(8,2)
);

-- Teste da inserção
INSERT INTO produtos_codigo (nome, preco) VALUES
    ('Notebook Dell', 2500.00),
    ('Mouse Logitech', 150.00),
    ('Teclado Mecânico', 300.00);

SELECT * FROM produtos_codigo;
-- Resultado: PROD-000001, PROD-000002, PROD-000003
```

### Auto Incremento por Categoria
```sql
-- Sequence separada para cada categoria
CREATE SEQUENCE seq_produto_eletronicos START 1;
CREATE SEQUENCE seq_produto_roupas START 1;
CREATE SEQUENCE seq_produto_livros START 1;

-- Função para gerar código por categoria
CREATE OR REPLACE FUNCTION gerar_codigo_por_categoria(categoria TEXT)
RETURNS TEXT AS $$
DECLARE
    proximo_numero INTEGER;
    prefixo TEXT;
    nome_sequence TEXT;
BEGIN
    CASE categoria
        WHEN 'eletronicos' THEN
            nome_sequence := 'seq_produto_eletronicos';
            prefixo := 'ELE-';
        WHEN 'roupas' THEN
            nome_sequence := 'seq_produto_roupas';
            prefixo := 'ROU-';
        WHEN 'livros' THEN
            nome_sequence := 'seq_produto_livros';
            prefixo := 'LIV-';
        ELSE
            RAISE EXCEPTION 'Categoria não reconhecida: %', categoria;
    END CASE;
    
    EXECUTE 'SELECT nextval($1)' INTO proximo_numero USING nome_sequence;
    RETURN prefixo || LPAD(proximo_numero::TEXT, 4, '0');
END;
$$ LANGUAGE plpgsql;

-- Tabela de produtos com código por categoria
CREATE TABLE produtos_categoria (
    id SERIAL PRIMARY KEY,
    codigo VARCHAR(8),
    nome VARCHAR(100) NOT NULL,
    categoria VARCHAR(20) NOT NULL,
    preco DECIMAL(8,2)
);

-- Inserção com geração automática de código
INSERT INTO produtos_categoria (codigo, nome, categoria, preco) VALUES
    (gerar_codigo_por_categoria('eletronicos'), 'Smartphone', 'eletronicos', 800.00),
    (gerar_codigo_por_categoria('roupas'), 'Camiseta', 'roupas', 50.00),
    (gerar_codigo_por_categoria('livros'), 'SQL Cookbook', 'livros', 80.00);
```

## Trabalhando com UUIDs

### UUID como Alternativa ao Auto Incremento
```sql
-- Habilitar extensão UUID
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Tabela com UUID
CREATE TABLE sessoes (
    sessao_id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    usuario_id INTEGER NOT NULL,
    token VARCHAR(255) NOT NULL,
    data_criacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    data_expiracao TIMESTAMP NOT NULL
);

-- Inserção com UUID automático
INSERT INTO sessoes (usuario_id, token, data_expiracao) VALUES
    (1, 'abc123token', CURRENT_TIMESTAMP + INTERVAL '1 hour'),
    (2, 'def456token', CURRENT_TIMESTAMP + INTERVAL '2 hours');
```

## Migração e Conversão

### Converter SERIAL para IDENTITY
```sql
-- 1. Backup dos dados
CREATE TABLE usuarios_backup AS SELECT * FROM usuarios;

-- 2. Remover a constraint da sequence antiga
ALTER TABLE usuarios ALTER COLUMN id DROP DEFAULT;
DROP SEQUENCE IF EXISTS usuarios_id_seq CASCADE;

-- 3. Converter para IDENTITY
ALTER TABLE usuarios ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY;

-- 4. Ajustar o valor inicial se necessário
SELECT setval(pg_get_serial_sequence('usuarios', 'id'), 
              COALESCE((SELECT MAX(id) FROM usuarios), 0) + 1, false);
```

### Adicionar Auto Incremento a Tabela Existente
```sql
-- Adicionar coluna SERIAL a tabela existente
ALTER TABLE tabela_existente 
ADD COLUMN id SERIAL PRIMARY KEY;

-- Ou adicionar coluna IDENTITY
ALTER TABLE tabela_existente 
ADD COLUMN id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY;
```

## Troubleshooting Comum

### Problemas Frequentes e Soluções

#### 1. Erro "sequence already exists"
```sql
-- Verificar se sequence existe
SELECT EXISTS (
    SELECT 1 FROM pg_sequences 
    WHERE sequencename = 'minha_sequence'
);

-- Criar apenas se não existir
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_sequences WHERE sequencename = 'minha_sequence') THEN
        CREATE SEQUENCE minha_sequence START 1;
    END IF;
END $$;
```

#### 2. Sincronizar sequence após importação
```sql
-- Ajustar sequence após importar dados
SELECT setval('usuarios_id_seq', 
              (SELECT MAX(id) FROM usuarios));
```

#### 3. Gaps na numeração
```sql
-- Verificar gaps na sequência
WITH sequencia AS (
    SELECT generate_series(1, (SELECT MAX(id) FROM usuarios)) AS num
)
SELECT num as id_faltante
FROM sequencia
WHERE num NOT IN (SELECT id FROM usuarios)
ORDER BY num;
```

## Boas Práticas

### Recomendações Gerais
1. **Use IDENTITY para novos projetos**: É o padrão SQL e mais portável
2. **BIGSERIAL para alta volumetria**: Evita limitações de espaço
3. **Nunca modifique valores manualmente**: Pode causar conflitos
4. **Monitore o crescimento**: Planeje para evitar overflow
5. **Backup incluindo sequences**: Garanta que sequences sejam preservadas

### Exemplo de Monitoramento
```sql
-- View para monitorar usage de sequences
CREATE VIEW vw_monitoramento_sequences AS
SELECT 
    schemaname,
    sequencename,
    last_value,
    max_value,
    ROUND((last_value::FLOAT / max_value::FLOAT) * 100, 2) as percentual_usado,
    CASE 
        WHEN (last_value::FLOAT / max_value::FLOAT) > 0.8 THEN 'CRÍTICO'
        WHEN (last_value::FLOAT / max_value::FLOAT) > 0.6 THEN 'ATENÇÃO'
        ELSE 'OK'
    END as status
FROM pg_sequences
WHERE schemaname = 'public'
ORDER BY percentual_usado DESC;
```

### Performance
```sql
-- Otimizar sequences com cache
ALTER SEQUENCE usuarios_id_seq CACHE 100;

-- Para inserções em lote, considere desabilitar autocommit
-- e usar transações explícitas para melhor performance
```

Os campos de auto incremento são essenciais para manter a integridade e unicidade dos dados, oferecendo diferentes abordagens conforme a necessidade do projeto, desde implementações simples até sistemas complexos com numeração personalizada.